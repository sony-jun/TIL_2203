# https://www.acmicpc.net/problem/2565


n = int(input())
w = []
w_b = []
dp = [0 for i in range(n)]
for i in range(n):
    w.append(list(map(int, input().split())))
w.sort(key=lambda x: x[0])
for i in range(n):
    w_b.append(w[i][1])
for i in range(n):
    for j in range(i):
        if w_b[i] > w_b[j] and dp[i] < dp[j]:
            dp[i] = dp[j]
    dp[i] += 1
print(n - max(dp))


# LIS 알고리즘의 기본 유형 격 문제인데, 어디에 어떻게 활용해야 할지 아이디어가 핵심인 문제였다.

# A 전봇대를 기준으로 오름차순 정렬하는 것까진 생각해냈다. 이후에 B 전봇대의 모든 각 값에 대해, 기준 수로 두고 그 밑에 모든 수 중 자기보다 작은 수가 있는 경우, A에서의 값과 B에서의 값의 대소 관계가 다른(=전깃줄 교차) 상태이므로 그 줄을 지우는 방식으로 여러가지 잡다하고 지저분한 코드를 작성하다가 전부 실패했다.

# LIS 활용 문제인 건 알고 있었어서, LIS를 어떻게 활용해야할 지 고민했는데 이 것도 잘 안되서 결국 다른 사람 풀이를 참고했다.

# B 전봇대에서, "교차된 줄이 없는 그룹"의 상태는 그 값이 오름차순인 상태로 정의할 수 있다. 이 때, 구하고자 하는 것은 전깃줄을 없애는 최소 개수인데, 이는 곧 교차되지 않은 상태의 전깃줄을 최대한 많이 남기는 것과 같은 경우이다. 그리고 이 말은 "교차된 줄이 없는 그룹"이 최대, 즉 오름차순인 그룹의 최대, LIS를 구하는 것과 같은 말이다. 요게 내가 생각 못한 핵심! LIS를 구하고, N - LIS를 출력하면 통과

# A 전봇대와 B 전봇대를 잇는 전깃줄 edge 정보를 2차원 배열로 저장

# A 전봇대 기준(임의의 수 k에 대해 edge[k][0]) 오름차순 정렬(B 전봇대 기준으로 해도 됨)

# B 전봇대 값에 대해 LIS 구하기

# N - LIS 출력(전체 전깃줄 - 교차 없는 전깃줄 그룹 중 최대 길이)
